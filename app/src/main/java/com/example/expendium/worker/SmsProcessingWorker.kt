// worker/SmsProcessingWorker.kt
package com.example.expendium.worker

import android.content.Context
import android.util.Log
import androidx.hilt.work.HiltWorker
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.example.expendium.data.model.Transaction // Your Transaction data class
import com.example.expendium.data.model.TransactionType // Your TransactionType enum/sealed class
import com.example.expendium.data.repository.TransactionRepository
import dagger.assisted.Assisted
import dagger.assisted.AssistedInject
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Locale // For case-insensitive regex if needed and consistent string ops

@HiltWorker
class SmsProcessingWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val transactionRepository: TransactionRepository // Injected by Hilt!
) : CoroutineWorker(appContext, workerParams) {

    companion object {
        private const val TAG = "SmsProcessingWorker"
        const val KEY_SENDER = "SENDER"
        const val KEY_BODY = "BODY"
        const val KEY_TIMESTAMP = "TIMESTAMP"
    }

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        val sender = inputData.getString(KEY_SENDER)
        val messageBody = inputData.getString(KEY_BODY)
        val timestamp = inputData.getLong(KEY_TIMESTAMP, System.currentTimeMillis()) // Get timestamp

        if (sender.isNullOrBlank() || messageBody.isNullOrBlank()) {
            Log.e(TAG, "Sender or message body is null or blank in worker.")
            return@withContext Result.failure()
        }

        Log.i(TAG, "Worker processing SMS from $sender (Timestamp: $timestamp): $messageBody")

        try {
            val parsedDetails = parseTransactionDetails(messageBody, sender)

            if (parsedDetails != null) {
                val (amount, type, merchant, notes) = parsedDetails

                val transaction = Transaction(
                    // id will be auto-generated by Room
                    amount = amount,
                    transactionDate = timestamp, // Use SMS timestamp
                    type = type,
                    categoryId = null, // TODO: Implement category detection or set a default
                    merchantOrPayee = merchant,
                    notes = notes,
                    paymentMode = "SMS", // You could try to parse this too
                    isManual = false,
                    accountId = 1L // TODO: Link to a default or detected account
                )
                transactionRepository.insertTransaction(transaction)
                Log.i(TAG, "✅ Transaction successfully parsed and saved: $transaction")
                Result.success()
            } else {
                Log.w(TAG, "ℹ️ Could not parse required transaction details from SMS. Not saving.")
                // It's often better to Result.success() here if it's not a critical failure,
                // to prevent WorkManager from retrying non-transactional SMS.
                // If it was detected as a transaction but parsing failed, failure might be appropriate.
                // For now, let's consider it a success if it's not a transaction SMS.
                // The decision to call this worker should ideally happen after isTransactionSms check.
                Result.success() // Or Result.failure() if parsing *should* have succeeded.
            }
        } catch (e: Exception) {
            Log.e(TAG, "❌ Error processing or saving transaction in worker", e)
            Result.failure() // Indicate failure for retry if appropriate
        }
    }

    private data class ParsedDetails(
        val amount: Double,
        val type: TransactionType,
        val merchant: String,
        val notes: String
    )

    // --- Robust Parsing Logic ---
    private fun parseTransactionDetails(messageBody: String, sender: String): ParsedDetails? {
        val lowerBody = messageBody.lowercase(Locale.ROOT)
        val lowerSender = sender.lowercase(Locale.ROOT)

        // --- 1. Determine Transaction Type (Expense/Income) ---
        val type: TransactionType = when {
            listOf("debited", "spent", "paid", "purchase", "payment to", "withdrawal").any { lowerBody.contains(it) } -> TransactionType.EXPENSE
            listOf("credited", "received", "deposited", "payment from").any { lowerBody.contains(it) } -> TransactionType.INCOME
            else -> {
                Log.d(TAG, "Could not determine transaction type for: $messageBody")
                return null // Or default to one if appropriate for non-transaction SMS that slipped through
            }
        }

        // --- 2. Extract Amount ---
        // Regex to find amounts like: Rs.1,000.00, Rs 500, INR 23.50, ₹123, 5000.00 sent
        // Handles optional decimal part, commas.
        val amountRegex = """(?:rs\.?|inr|₹)\s*([\d,]+(?:\.\d{1,2})?)|([\d,]+(?:\.\d{1,2})?)\s*(?:rs\.?|inr|₹)|(?:amount of|amt)\s*(?:rs\.?|inr|₹)?\s*([\d,]+(?:\.\d{1,2})?)|([\d,]+(?:\.\d{1,2})?)\s*(?:debited|credited|sent|received|spent)""".toRegex(RegexOption.IGNORE_CASE)
        val amountMatch = amountRegex.find(messageBody)
        val amountString = amountMatch?.let {
            it.groups[1]?.value ?: it.groups[2]?.value ?: it.groups[3]?.value ?: it.groups[4]?.value
        }?.replace(",", "")
        val amount = amountString?.toDoubleOrNull()

        if (amount == null) {
            Log.d(TAG, "Could not extract amount from: $messageBody")
            return null
        }

        // --- 3. Extract Merchant/Payee/Source ---
        var merchant = "Unknown"
        // Try various patterns. Order might matter.
        val merchantPatterns = listOf(
            """(?:to|paid to|sent to|purchase at|spent at|payment to|debited for)\s+([A-Za-z0-9\s.&'@-]+?)(?:\s*(?:\.|on|avbl bal|avl bal|for|ref|txnid|upi|with|-))""".toRegex(RegexOption.IGNORE_CASE), // General pattern
            """(?:from|received from)\s+([A-Za-z0-9\s.&'@-]+?)(?:\s*(?:\.|on|avbl bal|avl bal|ref|txnid|upi|with|-))""".toRegex(RegexOption.IGNORE_CASE), // For income
            """UPI\s*payment\s*(?:to|from)\s*([A-Za-z0-9\s.&'@-]+?)(?:\s*(?:\(UPI\)|ref no|\.))""".toRegex(RegexOption.IGNORE_CASE), // UPI specific
            """VPA\s*([A-Za-z0-9@.]+?)(?:\s|$)""".toRegex(RegexOption.IGNORE_CASE), // To VPA
            """Merchant\s*([A-Za-z0-9\s.&'-]+?)(?:\s*(?:tx|Ref|on))""".toRegex(RegexOption.IGNORE_CASE)
        )

        for (pattern in merchantPatterns) {
            val merchantMatch = pattern.find(messageBody)
            if (merchantMatch?.groupValues?.get(1)?.isNotBlank() == true) {
                merchant = merchantMatch.groupValues[1].trim().replace(" VPA", "", ignoreCase = true) // Clean up common additions
                // Remove trailing "on dd/mm/yy" or similar if captured
                merchant = merchant.split(Regex("\\s+on\\s+\\d{1,2}[-/]\\d{1,2}"))[0].trim()
                merchant = merchant.split(Regex("\\s+Avl Bal"))[0].trim()
                merchant = merchant.split(Regex("\\s+Ref No"))[0].trim()
                break
            }
        }
        // If merchant is still "Unknown", consider using the sender if it's not a generic bank code
        if (merchant == "Unknown" && !isGenericBankSender(lowerSender)) {
            merchant = sender // Or a formatted version of sender
        }

        // --- 4. Create Notes ---
        val notes = "Auto-detected from SMS ($sender): $messageBody" // Keep the full SMS for reference

        Log.d(TAG, "Parsed: Amount=₹$amount, Type=$type, Merchant='$merchant'")
        return ParsedDetails(amount, type, merchant, notes)
    }

    private fun isGenericBankSender(lowerSender: String): Boolean {
        // List of sender IDs that are too generic to be a merchant name
        return listOf("bank", "alerts", "update", "notify", "verify", "otp").any { lowerSender.contains(it) } ||
                lowerSender.matches(Regex("^[A-Z]{2}-[A-Z0-9]{6,8}$")) // Common shortcodes like DM-HDFCBK
    }
}